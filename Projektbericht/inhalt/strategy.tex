\subsubsection{Strategie}
Das \textit{Strategie}-Muster wird dafür verwendet, falls es verwandet Klassen gibt, die sich in dessen Verhalten unterscheiden. Dieses Verhaltensmuster wird also eingesetzt, falls beispielsweise viele Algorithmen verwaltet werden sollen. Es wird hierbei auf die Algorithmen über eine zentrale Instanz zugegriffen.\\
Es treten hier folgen Elemente auf, welche in \autoref{abb:strategy} zu sehen sind, wobei die Erklärung der Komponenten zunächst verallgemeinert und anschließend anhand des Algorithmen-Beispiels verdeutlicht wird:
\begin{itemize}
\item \texttt{A-Strategie}: Diese abstrakte Klasse dient der Beschreibung der Methoden, die die Unterklassen besitzen sollen. Im Falle mehrerer Algorithmen könnte dies der Start besagter Algorithmen sein.
\item \texttt{KonkreteStrategie}: Hier werden beispielsweise die verschiedenen Algorithmen im Detail implementiert. \texttt{KonkreteStrategieA} und \texttt{KonkreteStrategieB} können in diesem Fall die Funktionalitäten beinhalten, die über die \textbf{algorithmus}-Methode einen Start der konkreten Algorithmen hervorbringen könnte.
\item \texttt{Kontext}: Dieses Element entscheidet darüber, welche Instanz von \texttt{A-Strategie} dem Aufrufer geliefert werden soll. In diesem Beispiel könnte die Art des zu liefernden Algorithmus in einer Konfigurationsdatei angegeben werden, welche beim Aufruf der \textbf{operation}-Methode eingelesen wird. Abschließend bekommt der Aufrufer eine Instanz der gewünschten Komponente.
\end{itemize}  

\begin{figure}[h]
\centering
\begin{tikzpicture}
\tikzumlset{fill class = white, fill template = white}
	\umlinterface[x=8]{A-Strategie}{ }{\umlvirt{ + algorithmus() : void} }
	\umlclass[x=5,y=-3]{KonkreteStrategieA} { }{+ algorithmus() : void}
	\umlclass[x=11,y=-3]{KonkreteStrategieB} { }{+ algorithmus() : void}
	\umlclass{Kontext}{} {+ operation() : void}
	
	\umlinherit{KonkreteStrategieA}{A-Strategie}
	\umlinherit{KonkreteStrategieB}{A-Strategie}
	\umlaggreg[arg=strategie, pos=0.5]{Kontext}{A-Strategie}
	\umlnote[y=-3, width=4cm, fill=white]{Kontext}{ruft auf:\\ strategie.algorithmus()}

\end{tikzpicture}
\caption{Strategie-Muster \cite{Goll.2014}}
\label{abb:strategy}
\end{figure}

Dieses Muster besitzt die folgenden Vorteile:\\
\begin{itemize}
\item Es wird aufgrund der Kapselung der \texttt{KonkretenStrategien} für eine Erleichterung der Erweiterung und Umstellung gesorgt.
\item Es können bedingte Anweisungen im Quellcode reduziert werden, da nun jede \texttt{Konkrete-Stategie} eine eigene Klasse darstellt.
\item Darauf folgend können die gemeinsamen Funktionalitäten der \texttt{KonkretenStrategien} herausarbeitet werden.
\end{itemize}
Eine negative Eigenschaft dieses Musters, ist der Kommunikations-Overhead zwischen den Instanzen \texttt{Kontext} und \texttt{A-Strategie}. Falls  beispielsweise \texttt{KonkreteStrategieA} und \texttt{Konkrete-StrategieB} unterschiedliche Informationen zum Erzeugen deren Instanzen benötigen, z.B. benötigt eine Klasse nur eine Anzahl an Iterationsschritten, wohingegen die andere Komponente zusätzlich mehrere Flags benötigt. In diesem Fall ist eine engere Kopplung zwischen \texttt{Kontext} und \texttt{A-Strategie} notwendig \cite[S. 315 ff.]{gamma.2011}.\\
Ähnlich zum Strategie-Muster gibt es das Template-Muster, welches im Folgenden weiter erläutert wird. Zusätzlich werden das Strategie- und Template-Muster verglichen.